### 4. Suponiendo Selective Repeat; tama√±o de ventana 4 y sabiendo que E indica que el mensaje lleg√≥ con errores. Indique en el siguiente gr√°fico, la numeraci√≥n de los ACK que el host B env√≠a al host A.

![alt text](ejercicio4.png)

Primero una definici√≥n de Selective Repeat, porque sali√≥ el concepto de la nada (no voy a las teor√≠as, no leo las diapositivas, no leo el libro ni veo los videos :D): Selective Repeat es un protocolo de control de errores usado en redes de computadoras para asegurar la entrega confiable de paquetes de datos. Es una de las implementaciones del Protocolo de Ventana Deslizante (Sliding Window Protocol).

A diferencia de otros protocolos como "Go-Back-N", este **solo** retransmite los paquetes que se han perdido o da√±ado.

- Ventanas de Env√≠o y Recepci√≥n: Tanto el remitente como el receptor mantienen una "ventana" de paquetes

    - Remitente: Define un rango de n√∫meros de secuencia de los paquetes que el remitente puede enviar sin esperar un ACK individual.
    - Receptor: Define el rango de n√∫meros de secuencia de los paquetes que el receptor est√° dispuesto a aceptar. La lave est√° en el que el receptor puede aceptar y almacenar paquetes fuera de orden, siempre y cuando est√©n dentro de su ventana.

>Como mi cerebro lo entiende:
>
>El receptor define una ventana en secuencia, ej. [1,2,3,4], donde puede recibir paquetes dentro de esa ventana fuera de orden, y notifica que lo recibi√≥, o puede recibir en orden, donde tambi√©n notifica que lo recibi√≥ y mueve la ventana, dej√°ndola en [2,3,4,5].
>Si se le env√≠a alg√∫n paquete fuera de la ventana, este se descarta y env√≠a un NACK, tambi√©n env√≠a un NACK en caso de faltarle alguno de los paquetes de la ventana.

- Numeraci√≥n de Secuencia: Cada paquete de datos tiene un n√∫mero de secuencia √∫nico.

- ACKs y NACKs (Negative ACK)

    - Cuando el receptor recibe un paquete correctamente, env√≠a un ACK para ese paquete espec√≠fico.
    - Si el receptor detecta un paquete perdido o da√±ado puede enviar un NACK para ese paquete en particular.

- Retransmisi√≥n Selectiva:

    - El remitente mantiene un temporizador para cada paquete enviado.
    - Si el remitente no recibe un ACK para un paquete dentro de un per√≠odo de tiempo determinado (timeout), o si recibe un NACK, retransmite **solo ese paquete** espec√≠fico. No necesita retransmitir todos los paquetes posteriores al perdido.

- Reordenamiento en el Receptor: Como el receptor puede recibir paquetes fuera de orden, debe tener la capacidad de almacenarlos en un buffer y despu√©s reordenarlos para entregarlos a la capa superior de la aplicaci√≥n en el orden correcto.

>**Lo mismo, mi entendimiento:**
>
>Soy el remitente, puedo enviar hasta X paquetes sin haber recibido un ACK por ellos. Si envi√© X paquetes y no recib√≠ ning√∫n ACK para mover/deslizar mi ventana, freno el env√≠o de nuevos paquetes hasta que el receptor env√≠e un ACK que libere espacio en mi ventana de env√≠o.
>
>Dejando de fingir demencia con un cambio de personalidad al remitente:
>
>Si el remitente envi√≥ los paquetes 1, 2, 3, 4 (ventana [1,2,3,4]) y no recibi√≥ ning√∫n ACK, no puede enviar el paquete 5 hasta que llegue un ACK para el paquete 1. Ac√° es cuando el remitente frena el env√≠o de **nuevos paquetes** (n√≥tese el √©nfasis, porque puede seguir enviando los ya enviados) que est√©n fuera de su ventana actual. No obstante (re formal ü§ì), sigue monitoreando y retransmitiendo los paquetes dentro de su ventana si sus temporizadores expiran o recibe un NACK.
>
>El temporizador es individual (por paquete) y se inicializa cuando son enviados, cuando un temporizador vence, retransmite el paquete correspondiente.
>
>Ahora soy el receptor üì™, supongamos que mi ventana de recepci√≥n es [5,6,7,8], estoy esperando el paquete 5 como el siguiente en orden, hay varios posibles escenarios:
>
>1) Espero el 5 y recibo el 5, env√≠o un ACK para 5 y lo entrego a la aplicaci√≥n (capa superior), como ya tengo el que esperaba en orden, deslizo mi ventana a [6,7,8,9].
>2) Espero el 5 y recibo el 7, como el 7 est√° dentro de mi ventana, lo acepto, lo almaceno en el buffer y env√≠o un ACK para 7.
>3) Espero el 5 y recibo el 10, no est√° dentro de mi ventana, por lo tanto lo considero inv√°lido y lo descarto.
>4) Tengo el 5, 7 y 8, puedo enviar un NACK para indicar que me falta el 6.
>5) Espero el 5 y recibo el 5, pero este vino corrupto, es decir, no pasa la prueba del checksum, lo descarto y no env√≠o un ACK. Me ser√° retransmitido en caso de que venza su temporizador o reciba otro paquete fuera de orden y env√≠e un NACK para el 5.
>
>**Datazo importante:** El tama√±o de la ventana de env√≠o y recepci√≥n debe ser el mismo (o la ventana del receptor un poco m√°s grande en algunas implementaciones espec√≠ficas).


ENTONCES, retomando el ejercicio (el ayudante en su cabeza: "la puta madre pendejo de mierda, consult√° algo de la materia", probably):

Seg√∫n entiendo lo que pasa es:

Tama√±o de ventana 4, podr√≠amos decir que es [1,2,3,4]

```ruby
Host A: Env√≠a 1
Host B: 1 - ACK
Deslizamiento de ventana [2,3,4,5]
Host A: Env√≠a 2
Host B: 2 - ACK
Deslizamiento de ventana [3,4,5,6]
Host A: Env√≠a 3 [FALLA]
Host A: Env√≠a 4
Host B: 4 - ACK
Host A: Env√≠a 5
Host B: 5 - ACK
Host A: Env√≠a 6
Host B: 6 - ACK

[TIMEOUT]

Host A: Retransmite 3
Host B: 3 - ACK
```

En mi cabeza tiene todo el sentido ü§† 